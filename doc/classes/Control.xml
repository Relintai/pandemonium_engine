<?xml version="1.0" encoding="UTF-8" ?>
<class name="Control" inherits="CanvasItem">
	<brief_description>
		All user interface nodes inherit from Control. A control's anchors and margins adapt its position and size relative to its parent.
	</brief_description>
	<description>
		Base class for all UI-related nodes. [Control] features a bounding rectangle that defines its extents, an anchor position relative to its parent control or the current viewport, and margins that represent an offset to the anchor. The margins update automatically when the node, any of its parents, or the screen size change.
		For more information on Godot's UI system, anchors, margins, and containers, see the related tutorials in the manual. To build flexible UIs, you'll need a mix of UI elements that inherit from [Control] and [Container] nodes.
		[b]User Interface nodes and input[/b]
		Godot sends input events to the scene's root node first, by calling [method Node._input]. [method Node._input] forwards the event down the node tree to the nodes under the mouse cursor, or in focus. To do so, it calls [method MainLoop._input_event]. Call [method accept_event] so no other node receives the event. Once you accept an input, it becomes handled so [method Node._unhandled_input] will not process it.
		Only one [Control] node can be in focus. Only the node in focus will receive events. To get the focus, call [method grab_focus]. [Control] nodes lose focus when another node grabs it, or if you hide the node in focus.
		Sets [member mouse_filter] to [constant MOUSE_FILTER_IGNORE] to tell a [Control] node to ignore mouse or touch events. You'll need it if you place an icon on top of a button.
		[Theme] resources change the Control's appearance. If you change the [Theme] on a [Control] node, it affects all of its children. To override some of the theme's parameters, call one of the [code]add_*_override[/code] methods, like [method add_font_override]. You can override the theme with the inspector.
		[b]Note:[/b] Theme items are [i]not[/i] [Object] properties. This means you can't access their values using [method Object.get] and [method Object.set]. Instead, use [method get_theme_color], [method get_theme_constant], [method get_theme_font], [method get_theme_icon], [method get_theme_stylebox], and the [code]add_*_override[/code] methods provided by this class.
	</description>
	<tutorials>
		<link title="GUI tutorial index">$DOCS_URL/tutorials/ui/index.md</link>
		<link title="Custom drawing in 2D">$DOCS_URL/tutorials/2d/custom_drawing_in_2d.md</link>
		<link title="Control node gallery">$DOCS_URL/tutorials/ui/control_node_gallery.md</link>
		<link title="All GUI Demos">https://github.com/Relintai/pandemonium_demo_projects/tree/master/gui</link>
	</tutorials>
	<methods>
		<method name="_get_minimum_size" qualifiers="virtual">
			<return type="Vector2" />
			<description>
				Virtual method to be implemented by the user. Returns the minimum size for this control. Alternative to [member rect_min_size] for controlling minimum size via code. The actual minimum size will be the max value of these two (in each axis separately).
				If not overridden, defaults to [constant Vector2.ZERO].
				[b]Note:[/b] This method will not be called when the script is attached to a [Control] node that already overrides its minimum size (e.g. [Label], [Button], [PanelContainer] etc.). It can only be used with most basic GUI nodes, like [Control], [Container], [Panel] etc.
			</description>
		</method>
		<method name="_gui_input" qualifiers="virtual">
			<return type="void" />
			<argument index="0" name="event" type="InputEvent" />
			<description>
				Virtual method to be implemented by the user. Use this method to process and accept inputs on UI elements. See [method accept_event].
				Example: clicking a control.
				[codeblock]
				func _gui_input(event):
				    if event is InputEventMouseButton:
				        if event.button_index == BUTTON_LEFT and event.pressed:
				            print("I've been clicked D:")
				[/codeblock]
				The event won't trigger if:
				* clicking outside the control (see [method has_point]);
				* control has [member mouse_filter] set to [constant MOUSE_FILTER_IGNORE];
				* control is obstructed by another [Control] on top of it, which doesn't have [member mouse_filter] set to [constant MOUSE_FILTER_IGNORE];
				* control's parent has [member mouse_filter] set to [constant MOUSE_FILTER_STOP] or has accepted the event;
				* it happens outside the parent's rectangle and the parent has either [member rect_clip_content] or [method rect_clip_content] enabled.
				[b]Note:[/b] Event position is relative to the control origin.
			</description>
		</method>
		<method name="_make_custom_tooltip" qualifiers="virtual">
			<return type="Control" />
			<argument index="0" name="for_text" type="String" />
			<description>
				Virtual method to be implemented by the user. Returns a [Control] node that should be used as a tooltip instead of the default one. The [code]for_text[/code] includes the contents of the [member hint_tooltip] property.
				The returned node must be of type [Control] or Control-derived. It can have child nodes of any type. It is freed when the tooltip disappears, so make sure you always provide a new instance (if you want to use a pre-existing node from your scene tree, you can duplicate it and pass the duplicated instance). When [code]null[/code] or a non-Control node is returned, the default tooltip will be used instead.
				The returned node will be added as child to a [PopupPanel], so you should only provide the contents of that panel. That [PopupPanel] can be themed using [method Theme.set_stylebox] for the type [code]"TooltipPanel"[/code] (see [member hint_tooltip] for an example).
				[b]Note:[/b] The tooltip is shrunk to minimal size. If you want to ensure it's fully visible, you might want to set its [member rect_min_size] to some non-zero value.
				Example of usage with a custom-constructed node:
				[codeblock]
				func _make_custom_tooltip(for_text):
				    var label = Label.new()
				    label.text = for_text
				    return label
				[/codeblock]
				Example of usage with a custom scene instance:
				[codeblock]
				func _make_custom_tooltip(for_text):
				    var tooltip = preload("res://SomeTooltipScene.tscn").instance()
				    tooltip.get_node("Label").text = for_text
				    return tooltip
				[/codeblock]
			</description>
		</method>
		<method name="accept_event">
			<return type="void" />
			<description>
				Marks an input event as handled. Once you accept an input event, it stops propagating, even to nodes listening to [method Node._unhandled_input] or [method Node._unhandled_key_input].
			</description>
		</method>
		<method name="add_theme_color_override">
			<return type="void" />
			<argument index="0" name="name" type="StringName" />
			<argument index="1" name="color" type="Color" />
			<description>
				Creates a local override for a theme [Color] with the specified [code]name[/code]. Local overrides always take precedence when fetching theme items for the control.
				See also [method get_color], [method remove_color_override].
				[b]Example of overriding a label's color and resetting it later:[/b]
				[codeblock]
				# Given the child Label node "MyLabel", override its font color with a custom value.
				$MyLabel.add_color_override("font_color", Color(1, 0.5, 0))
				# Reset the font color of the child label.
				$MyLabel.add_color_override("font_color", get_color("font_color", "Label"))
				[/codeblock]
			</description>
		</method>
		<method name="add_theme_constant_override">
			<return type="void" />
			<argument index="0" name="name" type="StringName" />
			<argument index="1" name="constant" type="int" />
			<description>
				Creates a local override for a theme constant with the specified [code]name[/code]. Local overrides always take precedence when fetching theme items for the control.
				See also [method get_constant], [method remove_constant_override].
			</description>
		</method>
		<method name="add_theme_font_override">
			<return type="void" />
			<argument index="0" name="name" type="StringName" />
			<argument index="1" name="font" type="Font" />
			<description>
				Creates a local override for a theme [Font] with the specified [code]name[/code]. Local overrides always take precedence when fetching theme items for the control.
				[b]Note:[/b] An override can be removed by assigning it a [code]null[/code] value, but use [method remove_font_override] instead.
				See also [method get_font].
			</description>
		</method>
		<method name="add_theme_icon_override">
			<return type="void" />
			<argument index="0" name="name" type="StringName" />
			<argument index="1" name="texture" type="Texture" />
			<description>
				Creates a local override for a theme icon with the specified [code]name[/code]. Local overrides always take precedence when fetching theme items for the control.
				[b]Note:[/b] An override can be removed by assigning it a [code]null[/code] value, but use [method remove_icon_override] instead.
				See also [method get_icon].
			</description>
		</method>
		<method name="add_theme_shader_override">
			<return type="void" />
			<argument index="0" name="name" type="StringName" />
			<argument index="1" name="shader" type="Shader" />
			<description>
				Creates a local override for a theme shader with the specified [code]name[/code]. Local overrides always take precedence when fetching theme items for the control.
				[b]Note:[/b] An override can be removed by assigning it a [code]null[/code] value, but use [method remove_shader_override] instead.
			</description>
		</method>
		<method name="add_theme_stylebox_override">
			<return type="void" />
			<argument index="0" name="name" type="StringName" />
			<argument index="1" name="stylebox" type="StyleBox" />
			<description>
				Creates a local override for a theme [StyleBox] with the specified [code]name[/code]. Local overrides always take precedence when fetching theme items for the control.
				[b]Note:[/b] An override can be removed by assigning it a [code]null[/code] value, but use [method remove_stylebox_override] instead.
				See also [method get_stylebox].
				[b]Example of modifying a property in a StyleBox by duplicating it:[/b]
				[codeblock]
				# The snippet below assumes the child node MyButton has a StyleBoxFlat assigned.
				# Resources are shared across instances, so we need to duplicate it
				# to avoid modifying the appearance of all other buttons.
				var new_stylebox_normal = $MyButton.get_stylebox("normal").duplicate()
				new_stylebox_normal.border_width_top = 3
				new_stylebox_normal.border_color = Color(0, 1, 0.5)
				$MyButton.add_stylebox_override("normal", new_stylebox_normal)
				# Remove the stylebox override.
				$MyButton.add_stylebox_override("normal", null)
				[/codeblock]
			</description>
		</method>
		<method name="can_drop_data" qualifiers="virtual">
			<return type="bool" />
			<argument index="0" name="position" type="Vector2" />
			<argument index="1" name="data" type="Variant" />
			<description>
				Godot calls this method to test if [code]data[/code] from a control's [method get_drag_data] can be dropped at [code]position[/code]. [code]position[/code] is local to this control.
				This method should only be used to test the data. Process the data in [method drop_data].
				[codeblock]
				func can_drop_data(position, data):
				    # Check position if it is relevant to you
				    # Otherwise, just check data
				    return typeof(data) == TYPE_DICTIONARY and data.has("expected")
				[/codeblock]
			</description>
		</method>
		<method name="drop_data" qualifiers="virtual">
			<return type="void" />
			<argument index="0" name="position" type="Vector2" />
			<argument index="1" name="data" type="Variant" />
			<description>
				Godot calls this method to pass you the [code]data[/code] from a control's [method get_drag_data] result. Godot first calls [method can_drop_data] to test if [code]data[/code] is allowed to drop at [code]position[/code] where [code]position[/code] is local to this control.
				[codeblock]
				func can_drop_data(position, data):
				    return typeof(data) == TYPE_DICTIONARY and data.has("color")

				func drop_data(position, data):
				    color = data["color"]
				[/codeblock]
			</description>
		</method>
		<method name="find_next_valid_focus" qualifiers="const">
			<return type="Control" />
			<description>
				Finds the next (below in the tree) [Control] that can receive the focus.
			</description>
		</method>
		<method name="find_prev_valid_focus" qualifiers="const">
			<return type="Control" />
			<description>
				Finds the previous (above in the tree) [Control] that can receive the focus.
			</description>
		</method>
		<method name="force_drag">
			<return type="void" />
			<argument index="0" name="data" type="Variant" />
			<argument index="1" name="preview" type="Control" />
			<description>
				Forces drag and bypasses [method get_drag_data] and [method set_drag_preview] by passing [code]data[/code] and [code]preview[/code]. Drag will start even if the mouse is neither over nor pressed on this control.
				The methods [method can_drop_data] and [method drop_data] must be implemented on controls that want to receive drop data.
			</description>
		</method>
		<method name="get_anchor" qualifiers="const">
			<return type="float" />
			<argument index="0" name="margin" type="int" enum="Margin" />
			<description>
				Returns the anchor identified by [code]margin[/code] constant from [enum Margin] enum. A getter method for [member anchor_bottom], [member anchor_left], [member anchor_right] and [member anchor_top].
			</description>
		</method>
		<method name="get_begin" qualifiers="const">
			<return type="Vector2" />
			<description>
				Returns [member margin_left] and [member margin_top]. See also [member rect_position].
			</description>
		</method>
		<method name="get_combined_minimum_size" qualifiers="const">
			<return type="Vector2" />
			<description>
				Returns combined minimum size from [member rect_min_size] and [method get_minimum_size].
			</description>
		</method>
		<method name="get_cursor_shape" qualifiers="const">
			<return type="int" enum="Control.CursorShape" />
			<argument index="0" name="position" type="Vector2" default="Vector2( 0, 0 )" />
			<description>
				Returns the mouse cursor shape the control displays on mouse hover. See [enum CursorShape].
			</description>
		</method>
		<method name="get_drag_data" qualifiers="virtual">
			<return type="Variant" />
			<argument index="0" name="position" type="Vector2" />
			<description>
				Godot calls this method to get data that can be dragged and dropped onto controls that expect drop data. Returns [code]null[/code] if there is no data to drag. Controls that want to receive drop data should implement [method can_drop_data] and [method drop_data]. [code]position[/code] is local to this control. Drag may be forced with [method force_drag].
				A preview that will follow the mouse that should represent the data can be set with [method set_drag_preview]. A good time to set the preview is in this method.
				[codeblock]
				func get_drag_data(position):
				    var mydata = make_data()
				    set_drag_preview(make_preview(mydata))
				    return mydata
				[/codeblock]
			</description>
		</method>
		<method name="get_end" qualifiers="const">
			<return type="Vector2" />
			<description>
				Returns [member margin_right] and [member margin_bottom].
			</description>
		</method>
		<method name="get_focus_neighbour" qualifiers="const">
			<return type="NodePath" />
			<argument index="0" name="margin" type="int" enum="Margin" />
			<description>
				Returns the focus neighbour identified by [code]margin[/code] constant from [enum Margin] enum. A getter method for [member focus_neighbour_bottom], [member focus_neighbour_left], [member focus_neighbour_right] and [member focus_neighbour_top].
			</description>
		</method>
		<method name="get_focus_owner" qualifiers="const">
			<return type="Control" />
			<description>
				Returns the control that has focus or [code]null[/code] if none.
			</description>
		</method>
		<method name="get_global_rect" qualifiers="const">
			<return type="Rect2" />
			<description>
				Returns the position and size of the control relative to the top-left corner of the screen. See [member rect_position] and [member rect_size].
			</description>
		</method>
		<method name="get_margin" qualifiers="const">
			<return type="float" />
			<argument index="0" name="margin" type="int" enum="Margin" />
			<description>
				Returns the anchor identified by [code]margin[/code] constant from [enum Margin] enum. A getter method for [member margin_bottom], [member margin_left], [member margin_right] and [member margin_top].
			</description>
		</method>
		<method name="get_minimum_size" qualifiers="const">
			<return type="Vector2" />
			<description>
				Returns the minimum size for this control. See [member rect_min_size].
			</description>
		</method>
		<method name="get_parent_area_size" qualifiers="const">
			<return type="Vector2" />
			<description>
				Returns the width/height occupied in the parent control.
			</description>
		</method>
		<method name="get_parent_control" qualifiers="const">
			<return type="Control" />
			<description>
				Returns the parent control node.
			</description>
		</method>
		<method name="get_rect" qualifiers="const">
			<return type="Rect2" />
			<description>
				Returns the position and size of the control relative to the top-left corner of the parent Control. See [member rect_position] and [member rect_size].
			</description>
		</method>
		<method name="get_rotation" qualifiers="const">
			<return type="float" />
			<description>
				Returns the rotation (in radians).
			</description>
		</method>
		<method name="get_theme_color" qualifiers="const">
			<return type="Color" />
			<argument index="0" name="name" type="StringName" />
			<argument index="1" name="theme_type" type="StringName" default="&quot;&quot;" />
			<description>
				Returns a [Color] from the first matching [Theme] in the tree if that [Theme] has a color item with the specified [code]name[/code] and [code]theme_type[/code]. If [code]theme_type[/code] is omitted the class name of the current control is used as the type, or [member theme_type_variation] if it is defined. If the type is a class name its parent classes are also checked, in order of inheritance.
				For the current control its local overrides are considered first (see [method add_color_override]), then its assigned [member theme]. After the current control, each parent control and its assigned [member theme] are considered; controls without a [member theme] assigned are skipped. If no matching [Theme] is found in the tree, a custom project [Theme] (see [member ProjectSettings.gui/theme/custom]) and the default [Theme] are used.
				[codeblock]
				func _ready():
				    # Get the font color defined for the current Control's class, if it exists.
				    modulate = get_color("font_color")
				    # Get the font color defined for the Button class.
				    modulate = get_color("font_color", "Button")
				[/codeblock]
			</description>
		</method>
		<method name="get_theme_constant" qualifiers="const">
			<return type="int" />
			<argument index="0" name="name" type="StringName" />
			<argument index="1" name="theme_type" type="StringName" default="&quot;&quot;" />
			<description>
				Returns a constant from the first matching [Theme] in the tree if that [Theme] has a constant item with the specified [code]name[/code] and [code]theme_type[/code].
				See [method get_color] for details.
			</description>
		</method>
		<method name="get_theme_default_font" qualifiers="const">
			<return type="Font" />
			<description>
				Returns the default font from the first matching [Theme] in the tree if that [Theme] has a valid [member Theme.default_font] value.
				See [method get_color] for details.
			</description>
		</method>
		<method name="get_theme_font" qualifiers="const">
			<return type="Font" />
			<argument index="0" name="name" type="StringName" />
			<argument index="1" name="theme_type" type="StringName" default="&quot;&quot;" />
			<description>
				Returns a [Font] from the first matching [Theme] in the tree if that [Theme] has a font item with the specified [code]name[/code] and [code]theme_type[/code].
				See [method get_color] for details.
			</description>
		</method>
		<method name="get_theme_icon" qualifiers="const">
			<return type="Texture" />
			<argument index="0" name="name" type="StringName" />
			<argument index="1" name="theme_type" type="StringName" default="&quot;&quot;" />
			<description>
				Returns an icon from the first matching [Theme] in the tree if that [Theme] has an icon item with the specified [code]name[/code] and [code]theme_type[/code].
				See [method get_color] for details.
			</description>
		</method>
		<method name="get_theme_stylebox" qualifiers="const">
			<return type="StyleBox" />
			<argument index="0" name="name" type="StringName" />
			<argument index="1" name="theme_type" type="StringName" default="&quot;&quot;" />
			<description>
				Returns a [StyleBox] from the first matching [Theme] in the tree if that [Theme] has a stylebox item with the specified [code]name[/code] and [code]theme_type[/code].
				See [method get_color] for details.
			</description>
		</method>
		<method name="get_tooltip" qualifiers="const">
			<return type="String" />
			<argument index="0" name="at_position" type="Vector2" default="Vector2( 0, 0 )" />
			<description>
				Returns the tooltip, which will appear when the cursor is resting over this control. See [member hint_tooltip].
			</description>
		</method>
		<method name="grab_click_focus">
			<return type="void" />
			<description>
				Creates an [InputEventMouseButton] that attempts to click the control. If the event is received, the control acquires focus.
				[codeblock]
				func _process(delta):
				    grab_click_focus() #when clicking another Control node, this node will be clicked instead
				[/codeblock]
			</description>
		</method>
		<method name="grab_focus">
			<return type="void" />
			<description>
				Steal the focus from another control and become the focused control (see [member focus_mode]).
				[b]Note[/b]: Using this method together with [method Object.call_deferred] makes it more reliable, especially when called inside [method Node._ready].
			</description>
		</method>
		<method name="has_focus" qualifiers="const">
			<return type="bool" />
			<description>
				Returns [code]true[/code] if this is the current focused control. See [member focus_mode].
			</description>
		</method>
		<method name="has_point" qualifiers="virtual">
			<return type="bool" />
			<argument index="0" name="point" type="Vector2" />
			<description>
				Virtual method to be implemented by the user. Returns whether the given [code]point[/code] is inside this control.
				If not overridden, default behavior is checking if the point is within control's Rect.
				[b]Note:[/b] If you want to check if a point is inside the control, you can use [code]get_rect().has_point(point)[/code].
			</description>
		</method>
		<method name="has_theme_color" qualifiers="const">
			<return type="bool" />
			<argument index="0" name="name" type="StringName" />
			<argument index="1" name="theme_type" type="StringName" default="&quot;&quot;" />
			<description>
				Returns [code]true[/code] if there is a matching [Theme] in the tree that has a color item with the specified [code]name[/code] and [code]theme_type[/code].
				See [method get_color] for details.
			</description>
		</method>
		<method name="has_theme_color_override" qualifiers="const">
			<return type="bool" />
			<argument index="0" name="name" type="StringName" />
			<description>
				Returns [code]true[/code] if there is a local override for a theme [Color] with the specified [code]name[/code] in this [Control] node.
				See [method add_color_override].
			</description>
		</method>
		<method name="has_theme_constant" qualifiers="const">
			<return type="bool" />
			<argument index="0" name="name" type="StringName" />
			<argument index="1" name="theme_type" type="StringName" default="&quot;&quot;" />
			<description>
				Returns [code]true[/code] if there is a matching [Theme] in the tree that has a constant item with the specified [code]name[/code] and [code]theme_type[/code].
				See [method get_color] for details.
			</description>
		</method>
		<method name="has_theme_constant_override" qualifiers="const">
			<return type="bool" />
			<argument index="0" name="name" type="StringName" />
			<description>
				Returns [code]true[/code] if there is a local override for a theme constant with the specified [code]name[/code] in this [Control] node.
				See [method add_constant_override].
			</description>
		</method>
		<method name="has_theme_font" qualifiers="const">
			<return type="bool" />
			<argument index="0" name="name" type="StringName" />
			<argument index="1" name="theme_type" type="StringName" default="&quot;&quot;" />
			<description>
				Returns [code]true[/code] if there is a matching [Theme] in the tree that has a font item with the specified [code]name[/code] and [code]theme_type[/code].
				See [method get_color] for details.
			</description>
		</method>
		<method name="has_theme_font_override" qualifiers="const">
			<return type="bool" />
			<argument index="0" name="name" type="StringName" />
			<description>
				Returns [code]true[/code] if there is a local override for a theme [Font] with the specified [code]name[/code] in this [Control] node.
				See [method add_font_override].
			</description>
		</method>
		<method name="has_theme_icon" qualifiers="const">
			<return type="bool" />
			<argument index="0" name="name" type="StringName" />
			<argument index="1" name="theme_type" type="StringName" default="&quot;&quot;" />
			<description>
				Returns [code]true[/code] if there is a matching [Theme] in the tree that has an icon item with the specified [code]name[/code] and [code]theme_type[/code].
				See [method get_color] for details.
			</description>
		</method>
		<method name="has_theme_icon_override" qualifiers="const">
			<return type="bool" />
			<argument index="0" name="name" type="StringName" />
			<description>
				Returns [code]true[/code] if there is a local override for a theme icon with the specified [code]name[/code] in this [Control] node.
				See [method add_icon_override].
			</description>
		</method>
		<method name="has_theme_shader_override" qualifiers="const">
			<return type="bool" />
			<argument index="0" name="name" type="StringName" />
			<description>
				Returns [code]true[/code] if there is a local override for a theme shader with the specified [code]name[/code] in this [Control] node.
				See [method add_shader_override].
			</description>
		</method>
		<method name="has_theme_stylebox" qualifiers="const">
			<return type="bool" />
			<argument index="0" name="name" type="StringName" />
			<argument index="1" name="theme_type" type="StringName" default="&quot;&quot;" />
			<description>
				Returns [code]true[/code] if there is a matching [Theme] in the tree that has a stylebox item with the specified [code]name[/code] and [code]theme_type[/code].
				See [method get_color] for details.
			</description>
		</method>
		<method name="has_theme_stylebox_override" qualifiers="const">
			<return type="bool" />
			<argument index="0" name="name" type="StringName" />
			<description>
				Returns [code]true[/code] if there is a local override for a theme [StyleBox] with the specified [code]name[/code] in this [Control] node.
				See [method add_stylebox_override].
			</description>
		</method>
		<method name="is_drag_successful" qualifiers="const">
			<return type="bool" />
			<description>
				Returns [code]true[/code] if a drag operation is successful. Alternative to [method Viewport.gui_is_drag_successful].
				Best used with [constant Node.NOTIFICATION_DRAG_END].
			</description>
		</method>
		<method name="is_focus_owner_in_shortcut_context" qualifiers="const">
			<return type="bool" />
			<description>
			</description>
		</method>
		<method name="minimum_size_changed">
			<return type="void" />
			<description>
				Invalidates the size cache in this node and in parent nodes up to toplevel. Intended to be used with [method get_minimum_size] when the return value is changed. Setting [member rect_min_size] directly calls this method automatically.
			</description>
		</method>
		<method name="release_focus">
			<return type="void" />
			<description>
				Give up the focus. No other control will be able to receive keyboard or gamepad input.
			</description>
		</method>
		<method name="remove_theme_color_override">
			<return type="void" />
			<argument index="0" name="name" type="StringName" />
			<description>
				Removes a theme override for a [Color] with the given [code]name[/code].
			</description>
		</method>
		<method name="remove_theme_constant_override">
			<return type="void" />
			<argument index="0" name="name" type="StringName" />
			<description>
				Removes a theme override for a constant with the given [code]name[/code].
			</description>
		</method>
		<method name="remove_theme_font_override">
			<return type="void" />
			<argument index="0" name="name" type="StringName" />
			<description>
				Removes a theme override for a [Font] with the given [code]name[/code].
			</description>
		</method>
		<method name="remove_theme_icon_override">
			<return type="void" />
			<argument index="0" name="name" type="StringName" />
			<description>
				Removes a theme override for an icon with the given [code]name[/code].
			</description>
		</method>
		<method name="remove_theme_shader_override">
			<return type="void" />
			<argument index="0" name="name" type="StringName" />
			<description>
				Removes a theme override for a shader with the given [code]name[/code].
			</description>
		</method>
		<method name="remove_theme_stylebox_override">
			<return type="void" />
			<argument index="0" name="name" type="StringName" />
			<description>
				Removes a theme override for a [StyleBox] with the given [code]name[/code].
			</description>
		</method>
		<method name="set_anchor">
			<return type="void" />
			<argument index="0" name="margin" type="int" enum="Margin" />
			<argument index="1" name="anchor" type="float" />
			<argument index="2" name="keep_margin" type="bool" default="false" />
			<argument index="3" name="push_opposite_anchor" type="bool" default="true" />
			<description>
				Sets the anchor identified by [code]margin[/code] constant from [enum Margin] enum to value [code]anchor[/code]. A setter method for [member anchor_bottom], [member anchor_left], [member anchor_right] and [member anchor_top].
				If [code]keep_margin[/code] is [code]true[/code], margins aren't updated after this operation.
				If [code]push_opposite_anchor[/code] is [code]true[/code] and the opposite anchor overlaps this anchor, the opposite one will have its value overridden. For example, when setting left anchor to 1 and the right anchor has value of 0.5, the right anchor will also get value of 1. If [code]push_opposite_anchor[/code] was [code]false[/code], the left anchor would get value 0.5.
			</description>
		</method>
		<method name="set_anchor_and_margin">
			<return type="void" />
			<argument index="0" name="margin" type="int" enum="Margin" />
			<argument index="1" name="anchor" type="float" />
			<argument index="2" name="offset" type="float" />
			<argument index="3" name="push_opposite_anchor" type="bool" default="false" />
			<description>
				Works the same as [method set_anchor], but instead of [code]keep_margin[/code] argument and automatic update of margin, it allows to set the margin offset yourself (see [method set_margin]).
			</description>
		</method>
		<method name="set_anchors_and_margins_preset">
			<return type="void" />
			<argument index="0" name="preset" type="int" enum="Control.LayoutPreset" />
			<argument index="1" name="resize_mode" type="int" enum="Control.LayoutPresetMode" default="0" />
			<argument index="2" name="margin" type="int" default="0" />
			<description>
				Sets both anchor preset and margin preset. See [method set_anchors_preset] and [method set_margins_preset].
			</description>
		</method>
		<method name="set_anchors_preset">
			<return type="void" />
			<argument index="0" name="preset" type="int" enum="Control.LayoutPreset" />
			<argument index="1" name="keep_margins" type="bool" default="false" />
			<description>
				Sets the anchors to a [code]preset[/code] from [enum Control.LayoutPreset] enum. This is the code equivalent to using the Layout menu in the 2D editor.
				If [code]keep_margins[/code] is [code]true[/code], control's position will also be updated.
			</description>
		</method>
		<method name="set_begin">
			<return type="void" />
			<argument index="0" name="position" type="Vector2" />
			<description>
				Sets [member margin_left] and [member margin_top] at the same time. Equivalent of changing [member rect_position].
			</description>
		</method>
		<method name="set_drag_forwarding">
			<return type="void" />
			<argument index="0" name="target" type="Control" />
			<description>
				Forwards the handling of this control's drag and drop to [code]target[/code] control.
				Forwarding can be implemented in the target control similar to the methods [method get_drag_data], [method can_drop_data], and [method drop_data] but with two differences:
				1. The function name must be suffixed with [b]_fw[/b]
				2. The function must take an extra argument that is the control doing the forwarding
				[codeblock]
				# ThisControl.gd
				extends Control
				func _ready():
				    set_drag_forwarding(target_control)

				# TargetControl.gd
				extends Control
				func can_drop_data_fw(position, data, from_control):
				    return true

				func drop_data_fw(position, data, from_control):
				    my_handle_data(data)

				func get_drag_data_fw(position, from_control):
				    set_drag_preview(my_preview)
				    return my_data()
				[/codeblock]
			</description>
		</method>
		<method name="set_drag_preview">
			<return type="void" />
			<argument index="0" name="control" type="Control" />
			<description>
				Shows the given control at the mouse pointer. A good time to call this method is in [method get_drag_data]. The control must not be in the scene tree. You should not free the control, and you should not keep a reference to the control beyond the duration of the drag. It will be deleted automatically after the drag has ended.
				[codeblock]
				export (Color, RGBA) var color = Color(1, 0, 0, 1)

				func get_drag_data(position):
				    # Use a control that is not in the tree
				    var cpb = ColorPickerButton.new()
				    cpb.color = color
				    cpb.rect_size = Vector2(50, 50)
				    set_drag_preview(cpb)
				    return color
				[/codeblock]
			</description>
		</method>
		<method name="set_end">
			<return type="void" />
			<argument index="0" name="position" type="Vector2" />
			<description>
				Sets [member margin_right] and [member margin_bottom] at the same time.
			</description>
		</method>
		<method name="set_focus_neighbour">
			<return type="void" />
			<argument index="0" name="margin" type="int" enum="Margin" />
			<argument index="1" name="neighbour" type="NodePath" />
			<description>
				Sets the anchor identified by [code]margin[/code] constant from [enum Margin] enum to [Control] at [code]neighbor[/code] node path. A setter method for [member focus_neighbour_bottom], [member focus_neighbour_left], [member focus_neighbour_right] and [member focus_neighbour_top].
			</description>
		</method>
		<method name="set_global_position">
			<return type="void" />
			<argument index="0" name="position" type="Vector2" />
			<argument index="1" name="keep_margins" type="bool" default="false" />
			<description>
				Sets the [member rect_global_position] to given [code]position[/code].
				If [code]keep_margins[/code] is [code]true[/code], control's anchors will be updated instead of margins.
			</description>
		</method>
		<method name="set_margin">
			<return type="void" />
			<argument index="0" name="margin" type="int" enum="Margin" />
			<argument index="1" name="offset" type="float" />
			<description>
				Sets the margin identified by [code]margin[/code] constant from [enum Margin] enum to given [code]offset[/code]. A setter method for [member margin_bottom], [member margin_left], [member margin_right] and [member margin_top].
			</description>
		</method>
		<method name="set_margins_preset">
			<return type="void" />
			<argument index="0" name="preset" type="int" enum="Control.LayoutPreset" />
			<argument index="1" name="resize_mode" type="int" enum="Control.LayoutPresetMode" default="0" />
			<argument index="2" name="margin" type="int" default="0" />
			<description>
				Sets the margins to a [code]preset[/code] from [enum Control.LayoutPreset] enum. This is the code equivalent to using the Layout menu in the 2D editor.
				Use parameter [code]resize_mode[/code] with constants from [enum Control.LayoutPresetMode] to better determine the resulting size of the [Control]. Constant size will be ignored if used with presets that change size, e.g. [code]PRESET_LEFT_WIDE[/code].
				Use parameter [code]margin[/code] to determine the gap between the [Control] and the edges.
			</description>
		</method>
		<method name="set_position">
			<return type="void" />
			<argument index="0" name="position" type="Vector2" />
			<argument index="1" name="keep_margins" type="bool" default="false" />
			<description>
				Sets the [member rect_position] to given [code]position[/code].
				If [code]keep_margins[/code] is [code]true[/code], control's anchors will be updated instead of margins.
			</description>
		</method>
		<method name="set_rotation">
			<return type="void" />
			<argument index="0" name="radians" type="float" />
			<description>
				Sets the rotation (in radians).
			</description>
		</method>
		<method name="set_size">
			<return type="void" />
			<argument index="0" name="size" type="Vector2" />
			<argument index="1" name="keep_margins" type="bool" default="false" />
			<description>
				Sets the size (see [member rect_size]).
				If [code]keep_margins[/code] is [code]true[/code], control's anchors will be updated instead of margins.
			</description>
		</method>
		<method name="show_modal">
			<return type="void" />
			<argument index="0" name="exclusive" type="bool" default="false" />
			<description>
				Displays a control as modal. Control must be a subwindow. Modal controls capture the input signals until closed or the area outside them is accessed. When a modal control loses focus, or the ESC key is pressed, they automatically hide. Modal controls are used extensively for popup dialogs and menus.
				If [code]exclusive[/code] is [code]true[/code], other controls will not receive input and clicking outside this control will not close it.
			</description>
		</method>
		<method name="warp_mouse">
			<return type="void" />
			<argument index="0" name="to_position" type="Vector2" />
			<description>
				Moves the mouse cursor to [code]to_position[/code], relative to [member rect_position] of this [Control].
			</description>
		</method>
	</methods>
	<members>
		<member name="anchor_bottom" type="float" setter="_set_anchor" getter="get_anchor" default="0.0">
			Anchors the bottom edge of the node to the origin, the center, or the end of its parent control. It changes how the bottom margin updates when the node moves or changes size. You can use one of the [enum Anchor] constants for convenience.
		</member>
		<member name="anchor_left" type="float" setter="_set_anchor" getter="get_anchor" default="0.0">
			Anchors the left edge of the node to the origin, the center or the end of its parent control. It changes how the left margin updates when the node moves or changes size. You can use one of the [enum Anchor] constants for convenience.
		</member>
		<member name="anchor_right" type="float" setter="_set_anchor" getter="get_anchor" default="0.0">
			Anchors the right edge of the node to the origin, the center or the end of its parent control. It changes how the right margin updates when the node moves or changes size. You can use one of the [enum Anchor] constants for convenience.
		</member>
		<member name="anchor_top" type="float" setter="_set_anchor" getter="get_anchor" default="0.0">
			Anchors the top edge of the node to the origin, the center or the end of its parent control. It changes how the top margin updates when the node moves or changes size. You can use one of the [enum Anchor] constants for convenience.
		</member>
		<member name="focus_mode" type="int" setter="set_focus_mode" getter="get_focus_mode" enum="Control.FocusMode" default="0">
			The focus access mode for the control (None, Click or All). Only one Control can be focused at the same time, and it will receive keyboard, gamepad, and mouse signals.
		</member>
		<member name="focus_neighbour_bottom" type="NodePath" setter="set_focus_neighbour" getter="get_focus_neighbour" default="NodePath(&quot;&quot;)">
			Tells Godot which node it should give focus to if the user presses the down arrow on the keyboard or down on a gamepad by default. You can change the key by editing the [code]ui_down[/code] input action. The node must be a [Control]. If this property is not set, Godot will give focus to the closest [Control] to the bottom of this one.
		</member>
		<member name="focus_neighbour_left" type="NodePath" setter="set_focus_neighbour" getter="get_focus_neighbour" default="NodePath(&quot;&quot;)">
			Tells Godot which node it should give focus to if the user presses the left arrow on the keyboard or left on a gamepad by default. You can change the key by editing the [code]ui_left[/code] input action. The node must be a [Control]. If this property is not set, Godot will give focus to the closest [Control] to the left of this one.
		</member>
		<member name="focus_neighbour_right" type="NodePath" setter="set_focus_neighbour" getter="get_focus_neighbour" default="NodePath(&quot;&quot;)">
			Tells Godot which node it should give focus to if the user presses the right arrow on the keyboard or right on a gamepad by default. You can change the key by editing the [code]ui_right[/code] input action. The node must be a [Control]. If this property is not set, Godot will give focus to the closest [Control] to the bottom of this one.
		</member>
		<member name="focus_neighbour_top" type="NodePath" setter="set_focus_neighbour" getter="get_focus_neighbour" default="NodePath(&quot;&quot;)">
			Tells Godot which node it should give focus to if the user presses the top arrow on the keyboard or top on a gamepad by default. You can change the key by editing the [code]ui_top[/code] input action. The node must be a [Control]. If this property is not set, Godot will give focus to the closest [Control] to the bottom of this one.
		</member>
		<member name="focus_next" type="NodePath" setter="set_focus_next" getter="get_focus_next" default="NodePath(&quot;&quot;)">
			Tells Godot which node it should give focus to if the user presses [kbd]Tab[/kbd] on a keyboard by default. You can change the key by editing the [code]ui_focus_next[/code] input action.
			If this property is not set, Godot will select a "best guess" based on surrounding nodes in the scene tree.
		</member>
		<member name="focus_previous" type="NodePath" setter="set_focus_previous" getter="get_focus_previous" default="NodePath(&quot;&quot;)">
			Tells Godot which node it should give focus to if the user presses [kbd]Shift + Tab[/kbd] on a keyboard by default. You can change the key by editing the [code]ui_focus_prev[/code] input action.
			If this property is not set, Godot will select a "best guess" based on surrounding nodes in the scene tree.
		</member>
		<member name="grow_horizontal" type="int" setter="set_h_grow_direction" getter="get_h_grow_direction" enum="Control.GrowDirection" default="1">
			Controls the direction on the horizontal axis in which the control should grow if its horizontal minimum size is changed to be greater than its current size, as the control always has to be at least the minimum size.
		</member>
		<member name="grow_vertical" type="int" setter="set_v_grow_direction" getter="get_v_grow_direction" enum="Control.GrowDirection" default="1">
			Controls the direction on the vertical axis in which the control should grow if its vertical minimum size is changed to be greater than its current size, as the control always has to be at least the minimum size.
		</member>
		<member name="hint_tooltip" type="String" setter="set_tooltip" getter="_get_tooltip" default="&quot;&quot;">
			Changes the tooltip text. The tooltip appears when the user's mouse cursor stays idle over this control for a few moments, provided that the [member mouse_filter] property is not [constant MOUSE_FILTER_IGNORE]. You can change the time required for the tooltip to appear with [code]gui/timers/tooltip_delay_sec[/code] option in Project Settings.
			The tooltip popup will use either a default implementation, or a custom one that you can provide by overriding [method _make_custom_tooltip]. The default tooltip includes a [PopupPanel] and [Label] whose theme properties can be customized using [Theme] methods with the [code]"TooltipPanel"[/code] and [code]"TooltipLabel"[/code] respectively. For example:
			[codeblock]
			var style_box = StyleBoxFlat.new()
			style_box.set_bg_color(Color(1, 1, 0))
			style_box.set_border_width_all(2)
			# We assume here that the `theme` property has been assigned a custom Theme beforehand.
			theme.set_stylebox("panel", "TooltipPanel", style_box)
			theme.set_color("font_color", "TooltipLabel", Color(0, 1, 1))
			[/codeblock]
		</member>
		<member name="input_pass_on_modal_close_click" type="bool" setter="set_pass_on_modal_close_click" getter="get_pass_on_modal_close_click" default="true">
			Enables whether input should propagate when you close the control as modal.
			If [code]false[/code], stops event handling at the viewport input event handling. The viewport first hides the modal and after marks the input as handled.
		</member>
		<member name="margin_bottom" type="float" setter="set_margin" getter="get_margin" default="0.0">
			Distance between the node's bottom edge and its parent control, based on [member anchor_bottom].
			Margins are often controlled by one or multiple parent [Container] nodes, so you should not modify them manually if your node is a direct child of a [Container]. Margins update automatically when you move or resize the node.
		</member>
		<member name="margin_left" type="float" setter="set_margin" getter="get_margin" default="0.0">
			Distance between the node's left edge and its parent control, based on [member anchor_left].
			Margins are often controlled by one or multiple parent [Container] nodes, so you should not modify them manually if your node is a direct child of a [Container]. Margins update automatically when you move or resize the node.
		</member>
		<member name="margin_right" type="float" setter="set_margin" getter="get_margin" default="0.0">
			Distance between the node's right edge and its parent control, based on [member anchor_right].
			Margins are often controlled by one or multiple parent [Container] nodes, so you should not modify them manually if your node is a direct child of a [Container]. Margins update automatically when you move or resize the node.
		</member>
		<member name="margin_top" type="float" setter="set_margin" getter="get_margin" default="0.0">
			Distance between the node's top edge and its parent control, based on [member anchor_top].
			Margins are often controlled by one or multiple parent [Container] nodes, so you should not modify them manually if your node is a direct child of a [Container]. Margins update automatically when you move or resize the node.
		</member>
		<member name="mouse_default_cursor_shape" type="int" setter="set_default_cursor_shape" getter="get_default_cursor_shape" enum="Control.CursorShape" default="0">
			The default cursor shape for this control. Useful for Godot plugins and applications or games that use the system's mouse cursors.
			[b]Note:[/b] On Linux, shapes may vary depending on the cursor theme of the system.
		</member>
		<member name="mouse_filter" type="int" setter="set_mouse_filter" getter="get_mouse_filter" enum="Control.MouseFilter" default="0">
			Controls whether the control will be able to receive mouse button input events through [method _gui_input] and how these events should be handled. Also controls whether the control can receive the [signal mouse_entered], and [signal mouse_exited] signals. See the constants to learn what each does.
		</member>
		<member name="physics_interpolation_mode" type="int" setter="set_physics_interpolation_mode" getter="get_physics_interpolation_mode" overrides="Node" enum="Node.PhysicsInterpolationMode" default="1" />
		<member name="rect_clip_content" type="bool" setter="set_clip_contents" getter="is_clipping_contents" default="false">
			Enables whether rendering of [CanvasItem] based children should be clipped to this control's rectangle. If [code]true[/code], parts of a child which would be visibly outside of this control's rectangle will not be rendered.
		</member>
		<member name="rect_global_position" type="Vector2" setter="_set_global_position" getter="get_global_position">
			The node's global position, relative to the world (usually to the top-left corner of the window).
		</member>
		<member name="rect_min_size" type="Vector2" setter="set_custom_minimum_size" getter="get_custom_minimum_size" default="Vector2( 0, 0 )">
			The minimum size of the node's bounding rectangle. If you set it to a value greater than (0, 0), the node's bounding rectangle will always have at least this size, even if its content is smaller. If it's set to (0, 0), the node sizes automatically to fit its content, be it a texture or child nodes.
		</member>
		<member name="rect_pivot_offset" type="Vector2" setter="set_pivot_offset" getter="get_pivot_offset" default="Vector2( 0, 0 )">
			By default, the node's pivot is its top-left corner. When you change its [member rect_scale], it will scale around this pivot. Set this property to [member rect_size] / 2 to center the pivot in the node's rectangle.
		</member>
		<member name="rect_position" type="Vector2" setter="_set_position" getter="get_position" default="Vector2( 0, 0 )">
			The node's position, relative to its parent. It corresponds to the rectangle's top-left corner. The property is not affected by [member rect_pivot_offset].
		</member>
		<member name="rect_rotation" type="float" setter="set_rotation_degrees" getter="get_rotation_degrees" default="0.0">
			The node's rotation around its pivot, in degrees. See [member rect_pivot_offset] to change the pivot's position.
		</member>
		<member name="rect_scale" type="Vector2" setter="set_scale" getter="get_scale" default="Vector2( 1, 1 )">
			The node's scale, relative to its [member rect_size]. Change this property to scale the node around its [member rect_pivot_offset]. The Control's [member hint_tooltip] will also scale according to this value.
			[b]Note:[/b] This property is mainly intended to be used for animation purposes. Text inside the Control will look pixelated or blurry when the Control is scaled. To support multiple resolutions in your project, use an appropriate viewport stretch mode as described in the [url=$DOCS_URL/tutorials/rendering/multiple_resolutions.html]documentation[/url] instead of scaling Controls individually.
			[b]Note:[/b] If the Control node is a child of a [Container] node, the scale will be reset to [code]Vector2(1, 1)[/code] when the scene is instanced. To set the Control's scale when it's instanced, wait for one frame using [code]yield(get_tree(), "idle_frame")[/code] then set its [member rect_scale] property.
		</member>
		<member name="rect_size" type="Vector2" setter="_set_size" getter="get_size" default="Vector2( 0, 0 )">
			The size of the node's bounding rectangle, in pixels. [Container] nodes update this property automatically.
		</member>
		<member name="shortcut_context" type="Node" setter="set_shortcut_context" getter="get_shortcut_context">
			The [Node] which must be a parent of the focused [Control] for the shortcut to be activated. If [code]null[/code], the shortcut can be activated when any control is focused (a global shortcut). This allows shortcuts to be accepted only when the user has a certain area of the GUI focused.
			Setting this will override the node [member shortcut_context_path] is pointing. You can get rid of this override by setting this back to null.
		</member>
		<member name="shortcut_context_path" type="NodePath" setter="set_shortcut_context_path" getter="get_shortcut_context_path" default="NodePath(&quot;&quot;)">
			The [NodePath] for the [Node] which must be a parent of the focused [Control] for the shortcut to be activated. If [code]null[/code], the shortcut can be activated when any control is focused (a global shortcut). This allows shortcuts to be accepted only when the user has a certain area of the GUI focused.
			[member shortcut_context] can be used to temporarily override this when needed.
		</member>
		<member name="size_flags_horizontal" type="int" setter="set_h_size_flags" getter="get_h_size_flags" default="1">
			Tells the parent [Container] nodes how they should resize and place the node on the X axis. Use one of the [enum SizeFlags] constants to change the flags. See the constants to learn what each does.
		</member>
		<member name="size_flags_stretch_ratio" type="float" setter="set_stretch_ratio" getter="get_stretch_ratio" default="1.0">
			If the node and at least one of its neighbours uses the [constant SIZE_EXPAND] size flag, the parent [Container] will let it take more or less space depending on this property. If this node has a stretch ratio of 2 and its neighbour a ratio of 1, this node will take two thirds of the available space.
		</member>
		<member name="size_flags_vertical" type="int" setter="set_v_size_flags" getter="get_v_size_flags" default="1">
			Tells the parent [Container] nodes how they should resize and place the node on the Y axis. Use one of the [enum SizeFlags] constants to change the flags. See the constants to learn what each does.
		</member>
		<member name="theme" type="Theme" setter="set_theme" getter="get_theme">
			Changing this property replaces the current [Theme] resource this node and all its [Control] children use.
		</member>
		<member name="theme_type_variation" type="StringName" setter="set_theme_type_variation" getter="get_theme_type_variation" default="@&quot;&quot;">
			The name of a theme type variation used by this [Control] to look up its own theme items. When empty, the class name of the node is used (e.g. [code]Button[/code] for the [Button] control), as well as the class names of all parent classes (in order of inheritance).
			When set, this property gives the highest priority to the type of the specified name. This type can in turn extend another type, forming a dependency chain. See [method Theme.set_type_variation]. If the theme item cannot be found using this type or its base types, lookup falls back on the class names.
			[b]Note:[/b] To look up [Control]'s own items use various [code]get_*[/code] methods without specifying [code]theme_type[/code].
			[b]Note:[/b] Theme items are looked for in the tree order, from branch to root, where each [Control] node is checked for its [member theme] property. The earliest match against any type/class name is returned. The project-level Theme and the default Theme are checked last.
		</member>
	</members>
	<signals>
		<signal name="focus_entered">
			<description>
				Emitted when the node gains focus.
			</description>
		</signal>
		<signal name="focus_exited">
			<description>
				Emitted when the node loses focus.
			</description>
		</signal>
		<signal name="gui_input">
			<argument index="0" name="event" type="InputEvent" />
			<description>
				Emitted when the node receives an [InputEvent].
			</description>
		</signal>
		<signal name="minimum_size_changed">
			<description>
				Emitted when the node's minimum size changes.
			</description>
		</signal>
		<signal name="modal_closed">
			<description>
				Emitted when a modal [Control] is closed. See [method show_modal].
			</description>
		</signal>
		<signal name="mouse_entered">
			<description>
				Emitted when the mouse enters the control's [code]Rect[/code] area, provided its [member mouse_filter] lets the event reach it.
				[b]Note:[/b] [signal mouse_entered] will not be emitted if the mouse enters a child [Control] node before entering the parent's [code]Rect[/code] area, at least until the mouse is moved to reach the parent's [code]Rect[/code] area.
			</description>
		</signal>
		<signal name="mouse_exited">
			<description>
				Emitted when the mouse leaves the control's [code]Rect[/code] area, provided its [member mouse_filter] lets the event reach it.
				[b]Note:[/b] [signal mouse_exited] will be emitted if the mouse enters a child [Control] node, even if the mouse cursor is still inside the parent's [code]Rect[/code] area.
				If you want to check whether the mouse truly left the area, ignoring any top nodes, you can use code like this:
				[codeblock]
				func _on_mouse_exited():
				    if not Rect2(Vector2(), rect_size).has_point(get_local_mouse_position()):
				        # Not hovering over area.
				[/codeblock]
			</description>
		</signal>
		<signal name="resized">
			<description>
				Emitted when the control changes size.
			</description>
		</signal>
		<signal name="size_flags_changed">
			<description>
				Emitted when one of the size flags changes. See [member size_flags_horizontal] and [member size_flags_vertical].
			</description>
		</signal>
	</signals>
	<constants>
		<constant name="FOCUS_NONE" value="0" enum="FocusMode">
			The node cannot grab focus. Use with [member focus_mode].
		</constant>
		<constant name="FOCUS_CLICK" value="1" enum="FocusMode">
			The node can only grab focus on mouse clicks. Use with [member focus_mode].
		</constant>
		<constant name="FOCUS_ALL" value="2" enum="FocusMode">
			The node can grab focus on mouse click, using the arrows and the Tab keys on the keyboard, or using the D-pad buttons on a gamepad. Use with [member focus_mode].
		</constant>
		<constant name="NOTIFICATION_RESIZED" value="40">
			Sent when the node changes size. Use [member rect_size] to get the new size.
		</constant>
		<constant name="NOTIFICATION_MOUSE_ENTER" value="41">
			Sent when the mouse pointer enters the node.
		</constant>
		<constant name="NOTIFICATION_MOUSE_EXIT" value="42">
			Sent when the mouse pointer exits the node.
		</constant>
		<constant name="NOTIFICATION_FOCUS_ENTER" value="43">
			Sent when the node grabs focus.
		</constant>
		<constant name="NOTIFICATION_FOCUS_EXIT" value="44">
			Sent when the node loses focus.
		</constant>
		<constant name="NOTIFICATION_THEME_CHANGED" value="45">
			Sent when the node's [member theme] changes, right before Godot redraws the control. Happens when you call one of the [code]add_*_override[/code] methods.
		</constant>
		<constant name="NOTIFICATION_MODAL_CLOSE" value="46">
			Sent when an open modal dialog closes. See [method show_modal].
		</constant>
		<constant name="NOTIFICATION_SCROLL_BEGIN" value="47">
			Sent when this node is inside a [ScrollContainer] which has begun being scrolled.
		</constant>
		<constant name="NOTIFICATION_SCROLL_END" value="48">
			Sent when this node is inside a [ScrollContainer] which has stopped being scrolled.
		</constant>
		<constant name="CURSOR_ARROW" value="0" enum="CursorShape">
			Show the system's arrow mouse cursor when the user hovers the node. Use with [member mouse_default_cursor_shape].
		</constant>
		<constant name="CURSOR_IBEAM" value="1" enum="CursorShape">
			Show the system's I-beam mouse cursor when the user hovers the node. The I-beam pointer has a shape similar to "I". It tells the user they can highlight or insert text.
		</constant>
		<constant name="CURSOR_POINTING_HAND" value="2" enum="CursorShape">
			Show the system's pointing hand mouse cursor when the user hovers the node.
		</constant>
		<constant name="CURSOR_CROSS" value="3" enum="CursorShape">
			Show the system's cross mouse cursor when the user hovers the node.
		</constant>
		<constant name="CURSOR_WAIT" value="4" enum="CursorShape">
			Show the system's wait mouse cursor when the user hovers the node. Often an hourglass.
		</constant>
		<constant name="CURSOR_BUSY" value="5" enum="CursorShape">
			Show the system's busy mouse cursor when the user hovers the node. Often an arrow with a small hourglass.
		</constant>
		<constant name="CURSOR_DRAG" value="6" enum="CursorShape">
			Show the system's drag mouse cursor, often a closed fist or a cross symbol, when the user hovers the node. It tells the user they're currently dragging an item, like a node in the Scene dock.
		</constant>
		<constant name="CURSOR_CAN_DROP" value="7" enum="CursorShape">
			Show the system's drop mouse cursor when the user hovers the node. It can be an open hand. It tells the user they can drop an item they're currently grabbing, like a node in the Scene dock.
		</constant>
		<constant name="CURSOR_FORBIDDEN" value="8" enum="CursorShape">
			Show the system's forbidden mouse cursor when the user hovers the node. Often a crossed circle.
		</constant>
		<constant name="CURSOR_VSIZE" value="9" enum="CursorShape">
			Show the system's vertical resize mouse cursor when the user hovers the node. A double-headed vertical arrow. It tells the user they can resize the window or the panel vertically.
		</constant>
		<constant name="CURSOR_HSIZE" value="10" enum="CursorShape">
			Show the system's horizontal resize mouse cursor when the user hovers the node. A double-headed horizontal arrow. It tells the user they can resize the window or the panel horizontally.
		</constant>
		<constant name="CURSOR_BDIAGSIZE" value="11" enum="CursorShape">
			Show the system's window resize mouse cursor when the user hovers the node. The cursor is a double-headed arrow that goes from the bottom left to the top right. It tells the user they can resize the window or the panel both horizontally and vertically.
		</constant>
		<constant name="CURSOR_FDIAGSIZE" value="12" enum="CursorShape">
			Show the system's window resize mouse cursor when the user hovers the node. The cursor is a double-headed arrow that goes from the top left to the bottom right, the opposite of [constant CURSOR_BDIAGSIZE]. It tells the user they can resize the window or the panel both horizontally and vertically.
		</constant>
		<constant name="CURSOR_MOVE" value="13" enum="CursorShape">
			Show the system's move mouse cursor when the user hovers the node. It shows 2 double-headed arrows at a 90 degree angle. It tells the user they can move a UI element freely.
		</constant>
		<constant name="CURSOR_VSPLIT" value="14" enum="CursorShape">
			Show the system's vertical split mouse cursor when the user hovers the node. On Windows, it's the same as [constant CURSOR_VSIZE].
		</constant>
		<constant name="CURSOR_HSPLIT" value="15" enum="CursorShape">
			Show the system's horizontal split mouse cursor when the user hovers the node. On Windows, it's the same as [constant CURSOR_HSIZE].
		</constant>
		<constant name="CURSOR_HELP" value="16" enum="CursorShape">
			Show the system's help mouse cursor when the user hovers the node, a question mark.
		</constant>
		<constant name="PRESET_TOP_LEFT" value="0" enum="LayoutPreset">
			Snap all 4 anchors to the top-left of the parent control's bounds. Use with [method set_anchors_preset].
		</constant>
		<constant name="PRESET_TOP_RIGHT" value="1" enum="LayoutPreset">
			Snap all 4 anchors to the top-right of the parent control's bounds. Use with [method set_anchors_preset].
		</constant>
		<constant name="PRESET_BOTTOM_LEFT" value="2" enum="LayoutPreset">
			Snap all 4 anchors to the bottom-left of the parent control's bounds. Use with [method set_anchors_preset].
		</constant>
		<constant name="PRESET_BOTTOM_RIGHT" value="3" enum="LayoutPreset">
			Snap all 4 anchors to the bottom-right of the parent control's bounds. Use with [method set_anchors_preset].
		</constant>
		<constant name="PRESET_CENTER_LEFT" value="4" enum="LayoutPreset">
			Snap all 4 anchors to the center of the left edge of the parent control's bounds. Use with [method set_anchors_preset].
		</constant>
		<constant name="PRESET_CENTER_TOP" value="5" enum="LayoutPreset">
			Snap all 4 anchors to the center of the top edge of the parent control's bounds. Use with [method set_anchors_preset].
		</constant>
		<constant name="PRESET_CENTER_RIGHT" value="6" enum="LayoutPreset">
			Snap all 4 anchors to the center of the right edge of the parent control's bounds. Use with [method set_anchors_preset].
		</constant>
		<constant name="PRESET_CENTER_BOTTOM" value="7" enum="LayoutPreset">
			Snap all 4 anchors to the center of the bottom edge of the parent control's bounds. Use with [method set_anchors_preset].
		</constant>
		<constant name="PRESET_CENTER" value="8" enum="LayoutPreset">
			Snap all 4 anchors to the center of the parent control's bounds. Use with [method set_anchors_preset].
		</constant>
		<constant name="PRESET_LEFT_WIDE" value="9" enum="LayoutPreset">
			Snap all 4 anchors to the left edge of the parent control. The left margin becomes relative to the left edge and the top margin relative to the top left corner of the node's parent. Use with [method set_anchors_preset].
		</constant>
		<constant name="PRESET_TOP_WIDE" value="10" enum="LayoutPreset">
			Snap all 4 anchors to the top edge of the parent control. The left margin becomes relative to the top left corner, the top margin relative to the top edge, and the right margin relative to the top right corner of the node's parent. Use with [method set_anchors_preset].
		</constant>
		<constant name="PRESET_RIGHT_WIDE" value="11" enum="LayoutPreset">
			Snap all 4 anchors to the right edge of the parent control. The right margin becomes relative to the right edge and the top margin relative to the top right corner of the node's parent. Use with [method set_anchors_preset].
		</constant>
		<constant name="PRESET_BOTTOM_WIDE" value="12" enum="LayoutPreset">
			Snap all 4 anchors to the bottom edge of the parent control. The left margin becomes relative to the bottom left corner, the bottom margin relative to the bottom edge, and the right margin relative to the bottom right corner of the node's parent. Use with [method set_anchors_preset].
		</constant>
		<constant name="PRESET_VCENTER_WIDE" value="13" enum="LayoutPreset">
			Snap all 4 anchors to a vertical line that cuts the parent control in half. Use with [method set_anchors_preset].
		</constant>
		<constant name="PRESET_HCENTER_WIDE" value="14" enum="LayoutPreset">
			Snap all 4 anchors to a horizontal line that cuts the parent control in half. Use with [method set_anchors_preset].
		</constant>
		<constant name="PRESET_WIDE" value="15" enum="LayoutPreset">
			Snap all 4 anchors to the respective corners of the parent control. Set all 4 margins to 0 after you applied this preset and the [Control] will fit its parent control. This is equivalent to the "Full Rect" layout option in the editor. Use with [method set_anchors_preset].
		</constant>
		<constant name="PRESET_MODE_MINSIZE" value="0" enum="LayoutPresetMode">
			The control will be resized to its minimum size.
		</constant>
		<constant name="PRESET_MODE_KEEP_WIDTH" value="1" enum="LayoutPresetMode">
			The control's width will not change.
		</constant>
		<constant name="PRESET_MODE_KEEP_HEIGHT" value="2" enum="LayoutPresetMode">
			The control's height will not change.
		</constant>
		<constant name="PRESET_MODE_KEEP_SIZE" value="3" enum="LayoutPresetMode">
			The control's size will not change.
		</constant>
		<constant name="SIZE_FILL" value="1" enum="SizeFlags">
			Tells the parent [Container] to expand the bounds of this node to fill all the available space without pushing any other node. Use with [member size_flags_horizontal] and [member size_flags_vertical].
		</constant>
		<constant name="SIZE_EXPAND" value="2" enum="SizeFlags">
			Tells the parent [Container] to let this node take all the available space on the axis you flag. If multiple neighboring nodes are set to expand, they'll share the space based on their stretch ratio. See [member size_flags_stretch_ratio]. Use with [member size_flags_horizontal] and [member size_flags_vertical].
		</constant>
		<constant name="SIZE_EXPAND_FILL" value="3" enum="SizeFlags">
			Sets the node's size flags to both fill and expand. See the 2 constants above for more information.
		</constant>
		<constant name="SIZE_SHRINK_CENTER" value="4" enum="SizeFlags">
			Tells the parent [Container] to center the node in itself. It centers the control based on its bounding box, so it doesn't work with the fill or expand size flags. Use with [member size_flags_horizontal] and [member size_flags_vertical].
		</constant>
		<constant name="SIZE_SHRINK_END" value="8" enum="SizeFlags">
			Tells the parent [Container] to align the node with its end, either the bottom or the right edge. It doesn't work with the fill or expand size flags. Use with [member size_flags_horizontal] and [member size_flags_vertical].
		</constant>
		<constant name="MOUSE_FILTER_STOP" value="0" enum="MouseFilter">
			The control will receive mouse button input events through [method _gui_input] if clicked on. And the control will receive the [signal mouse_entered] and [signal mouse_exited] signals. These events are automatically marked as handled, and they will not propagate further to other controls. This also results in blocking signals in other controls.
		</constant>
		<constant name="MOUSE_FILTER_PASS" value="1" enum="MouseFilter">
			The control will receive mouse button input events through [method _gui_input] if clicked on. And the control will receive the [signal mouse_entered] and [signal mouse_exited] signals. If this control does not handle the event, the parent control (if any) will be considered, and so on until there is no more parent control to potentially handle it. This also allows signals to fire in other controls. Even if no control handled it at all, the event will still be handled automatically, so unhandled input will not be fired.
		</constant>
		<constant name="MOUSE_FILTER_IGNORE" value="2" enum="MouseFilter">
			The control will not receive mouse button input events through [method _gui_input]. The control will also not receive the [signal mouse_entered] nor [signal mouse_exited] signals. This will not block other controls from receiving these events or firing the signals. Ignored events will not be handled automatically.
		</constant>
		<constant name="GROW_DIRECTION_BEGIN" value="0" enum="GrowDirection">
			The control will grow to the left or top to make up if its minimum size is changed to be greater than its current size on the respective axis.
		</constant>
		<constant name="GROW_DIRECTION_END" value="1" enum="GrowDirection">
			The control will grow to the right or bottom to make up if its minimum size is changed to be greater than its current size on the respective axis.
		</constant>
		<constant name="GROW_DIRECTION_BOTH" value="2" enum="GrowDirection">
			The control will grow in both directions equally to make up if its minimum size is changed to be greater than its current size.
		</constant>
		<constant name="ANCHOR_BEGIN" value="0" enum="Anchor">
			Snaps one of the 4 anchor's sides to the origin of the node's [code]Rect[/code], in the top left. Use it with one of the [code]anchor_*[/code] member variables, like [member anchor_left]. To change all 4 anchors at once, use [method set_anchors_preset].
		</constant>
		<constant name="ANCHOR_END" value="1" enum="Anchor">
			Snaps one of the 4 anchor's sides to the end of the node's [code]Rect[/code], in the bottom right. Use it with one of the [code]anchor_*[/code] member variables, like [member anchor_left]. To change all 4 anchors at once, use [method set_anchors_preset].
		</constant>
	</constants>
</class>
