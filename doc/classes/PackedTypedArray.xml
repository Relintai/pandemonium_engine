<?xml version="1.0" encoding="UTF-8" ?>
<class name="PackedTypedArray">
	<brief_description>
		A generic array datatype that enforces a given type in a space efficient manner.
	</brief_description>
	<description>
		A generic array that can contain several elements of any one type in a space efficient manner, accessible by a numerical index starting at 0. Negative indices can be used to count from the back, like in Python (-1 is the last element, -2 is the second to last, etc.).
		Unlike the normal [Array] and [TypedArray], this class stores everything internally as the most sapce efficient way as possible.
		Like [TypedArray], it enforces the given types.
		Unlike PoolVectors it does not use pool allocations, so it's not limited by the (compile time) preset memory pool size.
		[b]Examples:[/b]
		[codeblock]
		var packed_typed_array : PackedTypedArray = PackedTypedArray([ 1, 2, 3, 4]) # Type will be automatically inferred
		print(packed_typed_array[0]) # 1.
		print(packed_typed_array[2]) # 3.
		print(packed_typed_array[-1]) # 4.
		packed_typed_array[2] = "Some string" # Won't get set
		print(packed_typed_array[-2]) # 3.
		[/codeblock]
		Explicit type:
		[codeblock]
		var packed_typed_array : PackedTypedArray = PackedTypedArray("int", [ 1, 2, 3, 4])
		print(packed_typed_array[0]) # 1.
		packed_typed_array[0] = "Some string" # Won't get set
		print(packed_typed_array[0]) # 1.
		if !packed_typed_array.set(0, "Some string"):
		  print("Element wasn't set!") # This will be printed
		[/codeblock]
		Objects, and inheritance also works:
		[codeblock]
		var packed_typed_array : PackedTypedArray = PackedTypedArray("Mesh") # Only Mesh, and it's derived classes can be inserted.
		[/codeblock]
		Exporting TypedArrays also works:
		[codeblock]
		export(PackedTypedArray) var packed_typed_array : PackedTypedArray = PackedTypedArray("Mesh") # Only Mesh, and it's derived classes can be inserted (including the editor's gui).
		[/codeblock]
		Arrays can be concatenated using the [code]+[/code] operator:
		[codeblock]
		var packed_typed_array1 : PackedTypedArray = PackedTypedArray("String", ["One", "Two"])
		var packed_typed_array2 : PackedTypedArray = PackedTypedArray(["Three", "Four"])
		print(packed_typed_array1 + packed_typed_array2) # ["One", "Two", "Four", "Four"]
		[/codeblock]
		[b]Note:[/b] Concatenating with the [code]+=[/code] operator will create a new array, which has a cost. If you want to append another array to an existing array, [method append_array] is more efficient.
		[b]Note:[/b] Arrays are always passed by reference. To get a copy of an array that can be modified independently of the original array, use [method duplicate].
		[b]Note:[/b] When declaring an array with [code]const[/code], the array itself can still be mutated by defining the values at individual indices or pushing/removing elements. Using [code]const[/code] will only prevent assigning the constant with another value after it was initialized.
	</description>
	<tutorials>
	</tutorials>
	<methods>
		<method name="PackedTypedArray">
			<return type="PackedTypedArray" />
			<argument index="0" name="from" type="TypedArray" />
			<description>
				Constructs a packed typed array from a [TypedArray].
			</description>
		</method>
		<method name="PackedTypedArray">
			<return type="PackedTypedArray" />
			<argument index="0" name="from" type="Array" />
			<description>
				Constructs a packed typed array from an [Array].
			</description>
		</method>
		<method name="PackedTypedArray">
			<return type="PackedTypedArray" />
			<argument index="0" name="type_name" type="StringName" />
			<description>
				Constructs an empty packed typed array that only allows the type given by the type_name parameter.
			</description>
		</method>
		<method name="PackedTypedArray">
			<return type="PackedTypedArray" />
			<argument index="0" name="type_name" type="StringName" />
			<argument index="1" name="from" type="Variant" />
			<description>
				Constructs a packed typed array from the given value (has to be any array type), that only allows the type given by the type_name parameter.
			</description>
		</method>
		<method name="PackedTypedArray">
			<return type="PackedTypedArray" />
			<argument index="0" name="type_name" type="StringName" />
			<argument index="1" name="from" type="Variant" />
			<argument index="2" name="int_type" type="int" />
			<description>
				Constructs a packed typed array from the given value (has to be any array type), that only allows the type given by the type_name parameter.
				This constructor also sets up the internal int type.
			</description>
		</method>
		<method name="append">
			<return type="bool" />
			<argument index="0" name="value" type="Variant" />
			<description>
				Appends an element at the end of the array (alias of [method push_back]).
			</description>
		</method>
		<method name="append_array">
			<return type="bool" />
			<argument index="0" name="array" type="PackedTypedArray" />
			<description>
				Appends another packed typed array at the end of this array.
				[codeblock]
				var array1 = PackedTypedArray([1, 2, 3])
				var array2 = PackedTypedArray([4, 5, 6])
				array1.append_array(array2)
				print(array1) # Prints [1, 2, 3, 4, 5, 6].
				[/codeblock]
			</description>
		</method>
		<method name="append_from">
			<return type="bool" />
			<argument index="0" name="array" type="Variant" />
			<description>
				Appends any elements possible from the given array at the end of this array.
				Returns true if any element was appended, false otherwise.
			</description>
		</method>
		<method name="back">
			<return type="Variant" />
			<description>
				Returns the last element of the array. Prints an error and returns [code]null[/code] if the array is empty.
				[b]Note:[/b] Calling this function is not the same as writing [code]array[-1][/code]. If the array is empty, accessing by index will pause project execution when running from the editor.
			</description>
		</method>
		<method name="bsearch">
			<return type="int" />
			<argument index="0" name="value" type="Variant" />
			<argument index="1" name="before" type="bool" default="true" />
			<description>
				Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a [code]before[/code] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array.
				[b]Note:[/b] Calling [method bsearch] on an unsorted array results in unexpected behavior.
			</description>
		</method>
		<method name="bsearch_custom">
			<return type="int" />
			<argument index="0" name="value" type="Variant" />
			<argument index="1" name="obj" type="Object" />
			<argument index="2" name="func" type="String" />
			<argument index="3" name="before" type="bool" default="true" />
			<description>
				Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search and a custom comparison method declared in the [code]obj[/code]. Optionally, a [code]before[/code] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array. The custom method receives two arguments (an element from the array and the value searched for) and must return [code]true[/code] if the first argument is less than the second, and return [code]false[/code] otherwise.
				[codeblock]
				func cardinal_to_algebraic(a):
				    match a:
				        "one":
				            return 1
				        "two":
				            return 2
				        "three":
				            return 3
				        "four":
				            return 4
				        _:
				            return 0

				func compare(a, b):
				    return cardinal_to_algebraic(a) &lt; cardinal_to_algebraic(b)

				func _ready():
				    var a = PackedTypedArray(["one", "two", "three", "four"])
				    # `compare` is defined in this object, so we use `self` as the `obj` parameter.
				    print(a.bsearch_custom("three", self, "compare", true)) # Expected value is 2.
				[/codeblock]
				[b]Note:[/b] Calling [method bsearch_custom] on an unsorted array results in unexpected behavior.
			</description>
		</method>
		<method name="can_take_variant">
			<return type="bool" />
			<argument index="0" name="value" type="Variant" />
			<description>
				Returns true if the given value can be added to the array, false otherwise.
			</description>
		</method>
		<method name="clear">
			<description>
				Clears the array. This is equivalent to using [method resize] with a size of [code]0[/code].
			</description>
		</method>
		<method name="count">
			<return type="int" />
			<argument index="0" name="value" type="Variant" />
			<description>
				Returns the number of times an element is in the array.
			</description>
		</method>
		<method name="duplicate">
			<return type="PackedTypedArray" />
			<argument index="0" name="deep" type="bool" default="false" />
			<description>
				Returns a copy of the array.
				If [code]deep[/code] is [code]true[/code], a deep copy is performed: all nested arrays and dictionaries are duplicated and will not be shared with the original array. If [code]false[/code], a shallow copy is made and references to the original nested arrays and dictionaries are kept, so that modifying a sub-array or dictionary in the copy will also impact those referenced in the source array.
			</description>
		</method>
		<method name="empty">
			<return type="bool" />
			<description>
				Returns [code]true[/code] if the array is empty.
			</description>
		</method>
		<method name="erase">
			<argument index="0" name="value" type="Variant" />
			<description>
				Removes the first occurrence of a value from the array. If the value does not exist in the array, nothing happens. To remove an element by index, use [method remove] instead.
				[b]Note:[/b] This method acts in-place and doesn't return a value.
				[b]Note:[/b] On large arrays, this method will be slower if the removed element is close to the beginning of the array (index 0). This is because all elements placed after the removed element have to be reindexed.
			</description>
		</method>
		<method name="fill">
			<return type="bool" />
			<argument index="0" name="value" type="Variant" />
			<description>
				Assigns the given value to all elements in the array. This can typically be used together with [method resize] to create an array with a given size and initialized elements:
				Returns true if the given value was added to the array at least once, false otherwise.
				[codeblock]
				var array = PackedTypedArray("int")
				array.resize(10)
				array.fill(0) # Initialize the 10 elements to 0.
				[/codeblock]
				[b]Note:[/b] If [code]value[/code] is of a reference type ([Object]-derived, [Array], [Dictionary], etc.) then the array is filled with the references to the same object, i.e. no duplicates are created.
			</description>
		</method>
		<method name="find">
			<return type="int" />
			<argument index="0" name="what" type="Variant" />
			<argument index="1" name="from" type="int" default="0" />
			<description>
				Searches the array for a value and returns its index or [code]-1[/code] if not found. Optionally, the initial search index can be passed. Returns [code]-1[/code] if [code]from[/code] is out of bounds.
			</description>
		</method>
		<method name="find_last">
			<return type="int" />
			<argument index="0" name="value" type="Variant" />
			<description>
				Searches the array in reverse order for a value and returns its index or [code]-1[/code] if not found.
			</description>
		</method>
		<method name="front">
			<return type="Variant" />
			<description>
				Returns the first element of the array. Prints an error and returns [code]null[/code] if the array is empty.
				[b]Note:[/b] Calling this function is not the same as writing [code]array[0][/code]. If the array is empty, accessing by index will pause project execution when running from the editor.
			</description>
		</method>
		<method name="get_int_type">
			<return type="int" />
			<description>
				Returns the int type used internally when the type is set to TYPE_INT.
			</description>
		</method>
		<method name="get_object_class_name">
			<return type="StringName" />
			<description>
				If the type that is stored is [Object] derived (TYPE_OBJECT) then this will return the target object's name.
			</description>
		</method>
		<method name="get_typename_string">
			<return type="String" />
			<description>
				Returns the stored type as a string. If storing objects, this will return the object's name, if storing ints, it will return int, etc.
			</description>
		</method>
		<method name="get_variant_type">
			<return type="int" />
			<description>
				return the stored variant type.
			</description>
		</method>
		<method name="has">
			<return type="bool" />
			<argument index="0" name="value" type="Variant" />
			<description>
			</description>
		</method>
		<method name="hash">
			<return type="int" />
			<description>
			</description>
		</method>
		<method name="insert">
			<return type="bool" />
			<argument index="0" name="position" type="int" />
			<argument index="1" name="value" type="Variant" />
			<description>
			</description>
		</method>
		<method name="invert">
			<description>
			</description>
		</method>
		<method name="max">
			<return type="Variant" />
			<description>
			</description>
		</method>
		<method name="min">
			<return type="Variant" />
			<description>
			</description>
		</method>
		<method name="pop_at">
			<return type="Variant" />
			<argument index="0" name="position" type="int" />
			<description>
			</description>
		</method>
		<method name="pop_back">
			<return type="Variant" />
			<description>
			</description>
		</method>
		<method name="pop_front">
			<return type="Variant" />
			<description>
			</description>
		</method>
		<method name="push_back">
			<return type="bool" />
			<argument index="0" name="value" type="Variant" />
			<description>
			</description>
		</method>
		<method name="push_front">
			<return type="bool" />
			<argument index="0" name="value" type="Variant" />
			<description>
			</description>
		</method>
		<method name="remove">
			<argument index="0" name="position" type="int" />
			<description>
			</description>
		</method>
		<method name="resize">
			<argument index="0" name="size" type="int" />
			<description>
			</description>
		</method>
		<method name="rfind">
			<return type="int" />
			<argument index="0" name="what" type="Variant" />
			<argument index="1" name="from" type="int" default="-1" />
			<description>
			</description>
		</method>
		<method name="set_int_type">
			<argument index="0" name="int_type" type="int" />
			<description>
			</description>
		</method>
		<method name="set_object_class_name">
			<argument index="0" name="object_type_name" type="StringName" />
			<description>
			</description>
		</method>
		<method name="set_type_from">
			<argument index="0" name="array" type="PackedTypedArray" />
			<description>
			</description>
		</method>
		<method name="set_type_from_array_element">
			<argument index="0" name="array" type="Variant" />
			<description>
			</description>
		</method>
		<method name="set_type_from_name">
			<argument index="0" name="type_name" type="StringName" />
			<description>
			</description>
		</method>
		<method name="set_type_from_variant">
			<argument index="0" name="variant" type="Variant" />
			<description>
			</description>
		</method>
		<method name="set_variant_type">
			<argument index="0" name="variant_type" type="int" />
			<description>
			</description>
		</method>
		<method name="shuffle">
			<description>
			</description>
		</method>
		<method name="size">
			<return type="int" />
			<description>
			</description>
		</method>
		<method name="slice">
			<return type="PackedTypedArray" />
			<argument index="0" name="begin" type="int" />
			<argument index="1" name="end" type="int" />
			<argument index="2" name="step" type="int" default="1" />
			<argument index="3" name="deep" type="bool" default="false" />
			<description>
			</description>
		</method>
		<method name="sort">
			<description>
			</description>
		</method>
		<method name="sort_custom">
			<argument index="0" name="obj" type="Object" />
			<argument index="1" name="func" type="String" />
			<description>
			</description>
		</method>
		<method name="validate_object_type_name">
			<return type="bool" />
			<argument index="0" name="type_name" type="StringName" />
			<description>
			</description>
		</method>
		<method name="validate_type_name">
			<return type="bool" />
			<argument index="0" name="type_name" type="StringName" />
			<description>
			</description>
		</method>
	</methods>
	<constants>
		<constant name="INT_TYPE_SIGNED_8" value="1">
		</constant>
		<constant name="INT_TYPE_UNSIGNED_8" value="2">
		</constant>
		<constant name="INT_TYPE_SIGNED_16" value="3">
		</constant>
		<constant name="INT_TYPE_UNSIGNED_16" value="4">
		</constant>
		<constant name="INT_TYPE_SIGNED_32" value="5">
		</constant>
		<constant name="INT_TYPE_UNSIGNED_32" value="6">
		</constant>
		<constant name="INT_TYPE_SIGNED_64" value="7">
		</constant>
		<constant name="INT_TYPE_UNSIGNED_64" value="8">
		</constant>
	</constants>
</class>
